import { FieldError, ValidationError } from '../errors/ValidationError';

export type TransactionType = 'EXPENSE' | 'INCOME';

export function isTransactionType(type: string): type is TransactionType {
  return ['INCOME', 'EXPENSE'].includes(type);
}

export type TransactionRecurrence = 'ONE_TIME' | 'MONTHLY';

export function isTransactionRecurrence(recurrence: string): recurrence is TransactionRecurrence {
  return ['ONE_TIME', 'MONTHLY'].includes(recurrence);
}

export interface Category {
  id: string;
  name: string;
}

export interface Account {
  id: string;
  name: string;
}

export class Transaction {
  id: string;
  userId: string;
  type: TransactionType;
  recurrence: TransactionRecurrence;
  category: Category;
  account: Account;
  amount: number;
  // date is provided by the user, where as createdAt and updatedAt are generated by the system
  date: Date;
  createdAt: Date;
  updatedAt: Date;
  description?: string;

  constructor(
    id: string,
    userId: string,
    type: TransactionType,
    recurrence: TransactionRecurrence,
    category: Category,
    account: Account,
    amount: number,
    date: Date,
    createdAt: Date,
    updatedAt: Date,
    description?: string
  ) {
    this.id = id;
    this.userId = userId;
    this.type = type;
    this.recurrence = recurrence;
    this.category = category;
    this.account = account;
    this.amount = amount;
    this.date = date;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.description = description;
  }

  validate() {
    const errors: FieldError[] = [];

    if (!this.id || !this.id.trim()) {
      errors.push({ field: 'id', message: 'this field cannot be empty' });
    }

    if (!this.userId || !this.userId.trim()) {
      errors.push({ field: 'userId', message: 'this field cannot be empty' });
    }

    if (this.amount <= 0) {
      errors.push({ field: 'balance', message: 'this field must greater than 0' });
    }

    if (errors.length) {
      throw new ValidationError(...errors);
    }
  }

  calculateAccountAmountToBeUpdated(newAmount?: number): number {
    const amount = newAmount ? newAmount - this.amount : this.amount;

    if (this.type == 'EXPENSE') {
      return -amount;
    }

    if (this.type == 'INCOME') {
      return amount;
    }

    throw new Error('Invalid type');
  }
}
